## ¿Qué son las pruebas y por qué deberíamos hacerlas? ##

¿Cuántas veces hemos sido usuarios de alguna app móvil y falla? ¿Cuántas veces hemos sido parte del desarrollo de un producto y el retrabajo se desborda por todas las fallas o defectos que contiene?.

Las pruebas son una manera de explorar, experimentar, entenderlo, entre menos entiendas el productos que estas desarrollando más errores tendrá. Las puedes hacer por cuestión de costo, prestigio o cuestiones legales.

Tres aspectos a considerar:

Tenemos un problema o el resultado no es el esperado
Nuestros costos se esta volviendo muy alto.
Implicaciones legales o de estándares tecnológicos.

¿Qué son las pruebas y por qué deberíamos hacerlas?

¿Qué son las pruebas?

Es el proceso de evaluar un producto, aprendiendo a través de la exploración y experimentación, lo cual incluye: Cuestionar, estudiar, modelar, observar e inferir, checar salidas de datos, etc.

¿Pasando todas las pruebas tendré un software sin errores?

No. El 100% de que un software no tenga errores nunca va a suceder; podrás llegar a estimaciones de 99.9999~ y quizás, dado el riesgo del software harás más pruebas pero siempre existe la posibilidad de que haya un nuevo fallo. El tiempo y los clientes nos han enseñado que no importa, aún cuando tengas un muy buen plan de pruebas, siempre se pueden ir algunos detalles.

Las pruebas las puedes tener que hacer por cuestiones de costo, prestigio, legales, o mejorar el software.

Muchas empresas que desarrollan software:

• No son parte de la solución.
• No siempre se entrega la evidencia al cliente.
• Sin una estructura o especificaciones son difíciles de mantener.
• No hay tiempo, o nadie del equipo hace pruebas.

Razones para hacer las pruebas

• Tenemos un problema o el resultado no es el esperado.
• Costo alto o fuera de presupuesto.
• Implicaciones legales o de estándares tecnológicos.


## Proceso de pruebas del software y los estándares internacionales ##

Para el proceso de pruebas es necesario contar con al menos 3 elementos que lograrán cumplir nuestros objetivos:

1.  Metodología: Es donde estableces el criterio o estrategia de cómo se llevaran acabo las pruebas.
2.  Recursos: Si quieres realizar pruebas y no estás preparado, con el tiempo esas carencias se pueden visualizar como defectos.
3.  Herramientas: Nos ayudarán a optimizar nuestro trabajo.

Definir la calidad del producto: Si estas creando el software correctamente.
Calidad del proceso: Si alguien de tu equipo no te especifica lo que quieres no vas a poder crear un producto que cubra sus necesidades.


Proceso de pruebas de software y los estándares

Metodología. Vendría siendo la parte en la que se establece el criterio o la estrategia de cómo vas a llevar a cabo tus pruebas; ya sea quiénes van a ser los responsables, cómo se va a entregar el material, etc.

Herramientas. Contar con herramientas adecuadas te va a permitir acelerar el trabajo de testing, porque muchas veces los equipos no trabajan en el mismo lugar.

Recursos. Aunque tú quieras hacer pruebas, si no estás preparado con el tiempo esas carencias se van a ir mostrando como defectos.

Pruebas en el ciclo de vida del software

Hay pruebas desde la concepción de los requisitos hasta su puesta final en producción.

De acuerdo aun estudio de IBM Systems Science Institute, 64% de les errores se producen durante el análisis y el diseño.

**¿Qué vamos a revisar durante las pruebas?
**
Calidad del producto. Si se está creando el software correctamente.
• Requerimientos
• Diseño
• Código
• El sistema

Calidad del proceso. Si alguien que es tu cliente no te especifica qué es lo que quieres, vas a crear un producto que no cubre las necesidades de tu cliente, así que una parte que se puede siempre tener en cuenta para evaluar como criterio de calidad pueden ser, los datos de salida del producto, o el proceso de calidad si se está siguiendo paso a paso.
• Estándares
• Procedimientos
• Procesos del proyecto

Certificaciones, estándares y metodologías

Una empresa para siempre poder proveer de un producto que cumpla las expectativas del cliente se puede enfocar en varias cosas.

• Para individuos
• Para procesos
• Para empresas
• Para servicios/productos = software/hardware
• Para tipo de industrias


## Ciclo de vida del software ##

A lo largo del ciclo de vida del software se realizan distintas pruebas para garantizar que este cumpla con los requerimientos para los que fue diseñado y de la misma forma se encuentren procesos de mejora y optimización a medida que se desarrolla el software.

Es necesario hacer pruebas en todas las fases del desarrollo de software ya que un error encontrado en una etapa tardía puede generar costos muy elevados.

Errores detectados lo antes posible reducen los costos y son mucho más fáciles de corregir.

El ciclo de vida permite que los errores se detecten lo antes posible y por lo tanto, permite a los desarrolladores concentrarse en la calidad del software, en los plazos de implementación y en los costos asociados.

El ciclo de vida básico de un software consta de los siguientes procedimientos:
imagen: testing_1.webp

Definición de objetivos
En esta fase se define el alcance general del software y su papel dentro de una estrategia global o dentro del ecosistema que va a funcionar.

Análisis de los requisitos y su viabilidad
Se trata de recopilar la mayor cantidad de información posible para evaluar la viabilidad del producto, encontrar posibles restricciones y analizar todos los requisitos del cliente.

Diseño
Alto nivel: Se trata de realizar un diseño básico que valide la arquitectura de la aplicación.
Bajo nivel: Es una definición detallada de la estructura de la aplicación basada en el diseño general.

Programación
Es la implementación de un lenguaje de programación para crear las funciones definidas durante la etapa de diseño.

Pruebas de verificación
Aunque en todas las fases anteriores se hacen pruebas en esta fase se cubren: pruebas de componentes, integrales y de sistema.

Prueba beta (o validación)
Se hace para garantizar que el software cumple con las especificaciones originales o también se hacen las pruebas de aceptación.

Implementación
Se realiza una prueba del sistema implementado para encontrar posibles fallas en la Implementación.

Mantenimiento
Se hace para todos los procedimientos correctivos (mantenimiento correctivo) y a las actualizaciones secundarias del software (mantenimiento continuo), junto con la actualización de las pruebas.

Si hacemos las pruebas durante cada fase del ciclo de vida del software tendremos al final del ciclo un producto validado y robusto de acuerdo a las necesidades del cliente.


## Proceso de pruebas del software: Calidad y Defectos ##

Todo lo anterior nos hace preguntarnos: ¿Qué es la calidad?

La calidad es una percepción entre lo deseado, analizado y lo que vamos a entregar. La calidad la define el cliente, si esa persona esta satisfecha con lo entregado hasta ahí llega la calidad.

    Verificación: Es ir en cada etapa revisando que se cumpla lo propuesto por el cliente.
    Validación: Antes de entregar al cliente, validamos que efectivamente el conjunto de requerimientos esta siendo cumplido con lo entregado.
    Anomalia: la manifestación de un error en el software.
    Error: una acción humana que produce un resultado incorrecto.
    Defecto: imperfección o deficiencia, el cual no cumple sus requerimientos o especificaciones y necesita ser reparado o remplazado.
    Fallo: el cese de la habilidad de un producto de cumplir una función requerida o su inhabilidad de funcionar dentro de márgenes previamente especificados.
    Problema: dificultad o incertidumbre experimentada por una o más personas, como resultado de un encuentro insatisfactorio con el sistema usado.

Ya entendimos que es necesario definir un proceso que asegure un buen desarrollo del producto, que los estándares o herramientas implementadas deben ayudar a cubrir las métricas definidas para entonces evaluar si el producto tiene el porcentaje o grado de calidad esperado.

    Anomalia: la manifestación de un error en el software.
    Error: una acción humana que produce un resultado incorrecto.
    Defecto: imperfección o deficiencia e un producto, el cual no cumple sus requerimientos o especificaciones y necesita ser reparado o remplazado.
    Fallo: el cese de la habilidad de un producto de cumplir una función requerida o su inhabilidad de funcionar dentro de márgenes previamente especificados.
    Problema: dificultad o incertidumbre experimentada por una o más personas, como resultado de un encuentro insatisfactorio con el sistema usado.

Proceso de pruebas del software: Calidad y Defectos

La calidad es una percepción entre lo deseado, lo analizado y lo que vamos a entregar. Entonces: La calidad la define el cliente.

¿Qué es la calidad?

“El grado con el que un sistema, componente o proceso cumple con los requisitos especificados y las necesidades o expectativas del cliente o usuario.”
IEEE.Stad.610-1990

Verificación y validación

A través de estas etapas se revisa que la documentación cumpla para todos los equipos. La **verificación ** es ir en cada una de las etapas revisando que se cumpla lo que el cliente pidió. La validación es antes de entregar al cliente validamos que efectivamente en el conjunto de todos los requerimientos todo lo entregado cumple.

Anomalía. Cualquier insatisfactoria condición.
Defecto. No desempeña funciones.
Fallo. Incapacidad dentro de márgenes.
Error. Acción humana incorrecta.

“El error humano cometido inyecta un defecto en el software que, ocasionalmente, se observa como una anomalía a causa de un comportamiento incorrecto, no acorde a lo especificado, que finalmente provoca el fallo del sistema software”


## Principios del testing moderno ##

1.  Nuestra prioridad es mejorar el negocio: El producto que se va a entregar al cliente permitirá hacer funcionar el negocio. Si en algún momento no quieres hacerlo, estás poniendo en riesgo ese negocio porque si el producto no se vende o no es aceptado la empresa puede cerrar o puedes perder el trabajo.
2. Nosotros aceleramos el equipo y usamos modelos como Lean Thinking y Teoría de las Restricciones para ayudar a identificar, priorizar y mitigar cuellos de botella en el sistema: Cuando queremos hacer algo, lo queremos hacer perfecto y eso puede ser demasiado. Deberías construir en base a procesos cortos para poder encontrar los defectos de una manera más rápida.
3. Nosotros somos la fuerza para la mejora continua, ayudando al equipo a adaptarse y optimizar para tener éxito, en lugar de proporcionar una red de seguridad para detectar fallas: El cliente puede entender que el producto se va a liberar por fases, es importante que nosotros enfoquemos nuestras pruebas en cada una de esas fases. No tiene que ser todo al inicio y al final, debe haber una distribución que nos permita manejar el riesgo del software
4. Nos preocupamos profundamente acerca de la cultura de calidad en nuestro equipo, y asesoramos, lideramos y nutrimos el equipo para llevarlos a una cultura de calidad más madura: Al inicio los testers eran personas desarrollando software y un día con tantos defectos y trabajo, separaron los roles para que así hubiese una persona dedicada a realizar las pruebas. El tester puede hacer recomendaciones de herramientas, mejorar el proceso o volverse un coach.
5. Nosotros creemos que el cliente es el único capaz de juzgar y evaluar la calidad de nuestro producto: Si el cliente esta satisfecho con lo entregado y cumple las expectativas entonces has alcanzado la calidad deseada.
6. Nosotros usamos datos de manera extensa y profunda para entender los casos de uso del cliente y entonces cerrar huecos entre hipótesis del producto e impacto del negocio.
7. Expandimos las habilidades de testing y el conocimiento en todo el equipo; entendemos que esto reduce o elimina la necesidad de una especialista dedicado al testing.

El tester debe dominar varias areas necesita entender y tener toda la visión del producto y negocio. Saber sobre herramientas que optimicen el trabajo.

Principios del testing moderno

Los principios creados por Allan Page y Brenn Jensen es acerca del testing moderno, que es la evolución natural del testing ágil. Veían la necesidad de que el tester y el desarrollador evolucionen en su perspectiva, ambos hacen software y entregan al mismo cliente, por lo tanto deben trabajar más como un equipo y no como entidades separadas. El tester debería enfocarse en la calidad del sowftware, el desarrollador debería enfocarse a desarrollar la solución. El tester va a ayudar al desarrollador a utilizar las mejores herramientas, a entender los procesos de pruebas, a mejorar la calidad de su desarrollo.

Los 7 principios del testing moderno

“Los testers podemos comenzar a pasar de ser los dueños de las pruebas o la calidad, a ser los embajadores de la calidad del producto”.

1. Nuesta prioridad es mejorar el negocio.
2. Nosotros aceleramos al equipo, usamos modelos como Lean Thinking y Teoría de las Restricciones para ayudar a identificar, mitigar, priorizar y mitigar cuellos de botella en el sistema.
3. Somos la fuerza para la mejora continua, ayudando al equipo a adaptarse y optimizar para tener éxito, en lugar de proporcionar una red de seguridad para detectar fallas.
4. Nos preocupamos profundamente acerca de la cultura de calidad en el equipo, y asesoramos, lideramos y nutrimos al equipo para llevarlos a una cultura de calidad más madura.
5. Nosotros creemos que le cliente es el único capaz de juzgar y evaluar la calidad de nuestro producto.
6. Nosotros usamos datos de manera extensa y profunda para entender los casos de usos del cliente y entonces cerrar huecos entre hipótesis del producto e impacto del negocio.
7. Expandimos las habilidades de testing y el conocimiento en todo el equipo; entendemos que esto reduce o elimina la necesidad de un especialista dedicado al testing.

### Lean Thinking ###: 
es un sistema enfocado en la creación de valor para el cliente, a través de la persistente búsqueda y eliminación de desperdicio, así como también la mejora continua, el respeto hacia las personas, el trabajo en equipo y abordar desafíos.

### Theory of Constraints ###: 
en una organización siempre habrán restricciones (maquinaria, procesos, políticas, personas…), en las cuales debemos enfocarnos y atacarlos de la sigueinte manera:

Identificar el cuello de botella
Explotarlo, llevándolo a su máxima capacidad.
Subordinar todo lo demás con el fin de solucionar el cuello de botella.
Elevar la capacidad con más maquinaria, personas, etc.
Iterar: siempre habrán más restricciones. Se debe evitar la inercia.


## Especialidades del testing ##

Hay muchas especialidades a la hora de hablar de testing y cada una de ellas tiene diferentes funciones y perspectivas que se incluyen en diferentes fases del proceso

Manual tester: Nos ayuda a definir los casos de pruebas, establecer estrategias. También ejecuta, pero lleva lo necesario para que todos sepan qué hacer.

    Pensamiento lateral, piensa fuera de la caja con una nueva perspectiva, agrega nuevos casos de usos y entiende muy bien al usuario.

Automation tester: Se encarga de agilizar, acelerar el trabajo y actividades que nos quitan la oportunidad de encontrar más casos de usos.

    Conoce de programación, no solo de forma básica, debe conocer como crear diseños de frameworks y soluciones. El código crece y las pruebas también, darle ese mantenimiento a las pruebas es un problema común.

Security tester: Encargado para el área de seguridad. Debe ser alguien que aporte valor desde la perspectiva de la seguridad.

    Protocolos, estándares, legalizaciones dependiendo de cada país y marca. Esta enfocado en prever ataques, virus, problemas de seguridad, acceso no autorizado. Profundizar en las técnicas y prácticas de seguridad.

Data science tester: Con la manera en que crecen los datos en un proyecto, se necesita a alguien que los analice, agrupe y limpie estos datos.

    Análisis y Limpieza de datos, omite tener un set de pruebas amplio donde la variedad va a permitir detectar defectos inesperados. Esto puede ser clave para que los resultados no sean falsos positivos

SDET: Es la combinacion de un desarrollador que ya sabe hacer pruebas. Con la diferencia de automatiza y hace uso de herramientas que organizan la operación de la entrega de las pruebas. Esta persona se asegura de que las pruebas se ejecuten antes de liberar el código.

    El programador ahora sabe hacer pruebas y conoce de herramientas que le permite entregarlas de una manera automatizada.

DevOps: Conoce todo lo anterior y domina el conocimiento de automatizar el proceso, se asegura de una entrega continua.

    Una automatización de la operación, Entrega Continua. Donde se entregan de forma más rápida las nuevas versiones.

QA Engineer: Quality Assurance. Esta enfocado en el producto y en el proceso.

    Procesos de Calidad

QE: Quality Engineer. Es como un coach, acompaña en las politicas de calidad en la empresa o equipo.

    Soluciones de estrategias de calidad.

Especialidades del testing

Manual tester. Nos ayuda a definir los casos de prueba, a establecer la estrategia, toda la parte que es más de planear y organizar, obviamente ejecuta, pero es mucho lo que lleva para lo que los demás sepan qué hacer. Sus principales características, siempre tiene un pensamiento lateral, piensa fuera de la caja, tiene una nueva perspectiva, agrega nuevos casos de uso, entiende muy bien al usuario.

Automation Tester. Él en realidad está pensando en cómo acelerar el trabajo, cómo acelerar las actividades que están quitándonos el enfoque de encontrar más casos de usos. El que automatiza debe de empezar a conocer herramientas que le permitan hacer mejor su trabajo. Sus principales características, debe conocer de programación, no solamente una forma básica, debe empezar a conocer cómo emplear diseños de frameworks y soluciones.

**Security Tester. ** Tiene una visión no solamente de los casos de uso, tiene que ver con la infraestructura, con puertos, con estándares. Sus principales características, está enfocado en pruebas de seguridad que permitan prever ataques, virus, problemas de seguridad, accesos no autorizados; profundizar en las técnicas y prácticas de seguridad es comprender protocolos, estándares, legalizaciones dependiendo cada país, cada producto o cada marca.

Data Science Tester. Se necesita alguien que analice, agrupe y limpie datos. Sus principales características, analizar y limpiar datos para que los resultados no sean falsos positivos.

SDET. Es una combinación de un desarrollador que sabe hacer pruebas. Se asegura de que las pruebas siempre se ejecuten antes de liberar el código. Sus principales características, conoce de herramientas que le permite liberar de una manera automatizada las pruebas; crean las pruebas, la automatizan y la suben a la nube dónde ellos pueden ejecutar estas pruebas cada vez que alguien del equipo libera un nuevo código.

DEVOPS. Conoce todo lo anterior pero además domina el conocimiento de automatizar la operación, está más especializado en la entrega continua. Sus principales características, automatización de la operación.

Qality Assurance Engineer. Está más enfocado en el producto y en el proceso. Sus principales características, aprender sobre procesos y productos.

Quality Engineer. Es más un coach, es el que acompaña en las políticas de calidad a la empresa y a todos los miembros del equipo. Sus principales características, entender políticas, coaching, programación, diseño, administración, escritura técnica, porque ya no sólo está probando software, también documentación, diseño, y tiene que saber comunicarlo a todo el equipo, ya sea de políticas o de comunicación interna. Su rol va más enfocado a que todos participan en la calidad.



## Presupuesto, Recursos, Tiempo y Actividades Clave ##

Pruebas para las Metodologías Ágiles

En contraste al modelo de cascada, _en un modelo ágil se escribe y actualiza un plan de prueba para cada lanzamiento. _

El plan de prueba ágil incluye los tipos de pruebas realizadas en esa iteración. Los planes de prueba típicos en ágil incluyen:

El alcance de la prueba
Prueba de las nuevas funcionalidades agregadas en la iteración.
Las pruebas deben ser basadas en la complejidad de las características.
Pruebas de desempeño (carga y rendimiento)
Consideraciones de infraestructura
Plan de Mitigación de Riesgos.
Recursos
Entregables e hitos


## Estrategia de pruebas ##

Las estrategias de prueba son aquellas que nos permiten conocer por donde comenzar. Por donde vamos a hacer las pruebas, planearlas, identificarlas. Para saber por donde comenzar podemos hacernos dos preguntas.

¿Qué problemas tenemos actualmente?
¿Qué problemas debemos evitar?

Son aquellas que nos permiten conoce por dónde comenzar. Por dónde vamos a hacer las pruebas, planearlas, identificarlas. Todos los testers normalmente lo que necesitan es por dónde comenzar.

¿Qué problema tenemos actualmente?

¿Qué problema debemos evitar?

Escenarios y Contextos

• Seguridad
• Arquitectura
• Performance
• Usabilidad
• Escalabilidad


## Testing en desarrollo de software ##

Testing: Es la exploración de una idea, aprender a conocer como sucede el flujo, se generan datos, se llenan formularios. Esto y la exploración de pruebas nunca terminan, siempre hay nuevas formas de conocer como el usuario esta usando el software

Checking: Es cuando sabes qué esta pasando y te verificas que siga pasando. Como verificar una maleta antes de viajar para asegurarnos que guardamos todo.

Solo se ejecutan si sucede algo
Se ejecutan cada que… libero nuevo código o software.
Se ejecutan de manera programada.

Testing vs Checking

Testing es la exploración de una idea, aprender a conocer cómo sucede un flujo, cómo se generan datos, cómo se llena un formulario, y esto te genere nuevos resultados, el testing y la exploración de pruebas nunca termina, siempre habrá nuevos escenarios que te permitan conocer otras formas en que el usuario está usando un software.

El Checking en cambio, es cuándo tú ya sabes que sucede algo y solamente estás verificando que siga pasando.

Estrategias del checking

• Solo se ejecutan si…
• Se ejecutan cada que…
• Se ejecutan de manera programada…

Errores comunes durante la ejecución

• Pruebas duplicadas
• Pruebas similares
• Pruebas sin valor agregado
• Pruebas caducadas

Distinguir entre el testing y el checking te lleva hacia la correcta automatización.

La automatización de pruebas consiste en el uso de software especial para controlar la ejecución de pruebas y la comparación entre los resultados obtenidos y los resultados esperados. Sin embargo, se trata de un checking repetitivo y automatizado.

Desventajas del checking mal empleado

• Pobre cobertura de pruebas
• Falta de actualización
• Mal manejo de versiones


## Testing ágil ##

Involucra a todos, no solo en al tester, todos en el equipo son tester. La persona con este rol se asegura de la mayor cobertura de pruebas tomando en cuenta todas las necesidades que cada uno de los miembros del equipo también esta intentando hacer que funcione. El tester tiene que definir si se esta cumpliendo con los requerimientos funciones y los del equipo.

Estrategias Ágiles:

    El testing es de ““todo el equipo””
    El testing puede ser independiente
    Integración continua
    Testing guiado por pruebas (Test Driven Development)
    Desarrollo guiado por comportamiento (Behaviour Driven Development)
    Desarrollo guiado por las pruebas de aceptación (Acceptance Test Driven Development)


Testing ágil

Testing ágil involucra a todos los miembros de un equipo ágil multifuncional, en el cual el rol del tester es el de un experto multifuncional, que garantiza se entregue el valor de negocio deseado al cliente a un ritmo sostenible y continuo.

Estrategias ágiles

• El testing es de “todo el equipo”
• El testing puede ser independiente (opcional)
• Integración continua
• Testing guiado por pruebas (Test Driven Development - TDD)
• Desarrollo guiado por comportamiento (Behaviour Driven Development - BDD)
• Desarrollo guiado por pruebas de aceptación (Acceptance Test Driven Development - ATDD)


## Niveles de pruebas ##

Vamos a ver diferentes estrategias de cómo podemos ir probando elementos por capas. Componentes, estructuras, etc.

Prueba de Componentes: Componentes son aquellas cosas pequeñas que sueles ver en un video como el botón de pausa, volumen, adelantar, retroceder. Cada una de esas acciones son un componente.

Pruebas de integración: Una aplicación tiene una serie de componentes que trabajando juntos forman un pequeño sistemas, pero cuando tienes varios de estos sistemas necesitas integrarlos entre ellos.

Prueba de sistema: Esta parte incluye que estás tomando en cuenta el contexto, no es lo mismo tener las mismas pruebas para iOS, Android y Web.

Pruebas de aceptación: Si ya probamos que nuestro elemento o acción funcionan, estás pruebas nos aseguran con o sin el cliente que tiene cubierta todas las necesidades requeridas en el software. Es la última verificación.

Niveles de Prueba de Software

Pruebas de Componentes

Son aquellas pequeñas cosas que puedes ver, botones, cajas de texto, etc.

Pruebas de Integración

Un sistema o aplicación tiene una serie de componentes que trabajando juntos son pequeños sistemas, teniendo múltiples sistemas juntos se necesita asegurar que se integren. Lo que hacen es, cómo desde un inicio hasta el final de un flujo de ejecución, todos los componentes se comunican, se integran.

Pruebas de Sistema

Incluye que además estás tomando en cuenta el contexto. Android, página Web, iOS, dispositivos IoT.

Pruebas de Aceptación

Debemos asegurarnos que las necesidades del cliente son cubiertas con el software.


## Tipos de pruebas ##

Necesitamos tener otra clasificación adicional. En los niveles sabemos la profundidad de las pruebas, pero en los tipos independientemente de su profundidad son las técnicas que vamos a usar para encontrar los defectos.

Pruebas funcionales: Cómo funciona un sistema, qué debe estar haciendo, cómo está interactuando el usuario con él.

Pruebas no-funcionales: El usuario puede estar experimentando otro tipo de cosas que aún funcionando puede tener la sensación de lentitud, falta de legibilidad o claridad. Esas características de usabilidad están asociadas a estas pruebas.

Pruebas estructurales: Tienen que ver con la tecnología y el stack usado para construir nuestro producto. Nos tenemos que asegurarnos que nuestra base de datos o servidor funcionen de la manera correcta. Son conocidas como pruebas de caja blanca.

Prueba de manejo de cambios: Es probar nuevamente un componente ya probado para verificar que no ha sido impactado por actualizaciones.

Tipos de Pruebas de Software

Cuando hablamos de tipos de pruebas, nos estamos refiriendo al grupo de actividades específicas que vamos a realizar, esto basado en objetivos.

Pruebas Funcionales

Se entiende como las funcionalidades del sistema como “lo que el sistema hace”.

Pruebas no Funcionales

El objetivo de es aes probar “cómo funciona el sistema”.

Pruebas Estructurales

Para poder llevar a cabo estas pruebas, normalmente el tester debe tener conocimientos acerca de la tecnología y el stack que se está empleando. Conocida como pruebas de caja blanca.

Pruebas de Manejo de Cambios

Es probar nuevamente un componente ya probado para verificar que no ha sido impactado por actualizaciones.



## Pruebas estáticas y dinámicas ##

Pruebas estáticas: Muchas veces no son consideradas en los proyectos porque significa revisar código, documentación, verificar información documentada de la forma correcta.

Pruebas dinámicas: Se enfocan en comportamientos externos visibles durante la ejecución del software.

Pruebas Estáticas y Dinámicas

“Las pruebas dinámicas se enfocan principalmente en comportamientos externos visibles durante la ejecución del software”.

“Las pruebas estáticas se basan en la examinación manual de los elementos que conforman la construcción del software”.

¿Qué son los elementos?

• Contratos, planes y calendario del proyecto, así como su presupuesto.
• El análisis de requerimientos
• Especificaciones o reglas de negocio
o Técnicos
o Seguridad
• Las definiciones de
o Historias del usuario
o Criterios de Aceptación
o Mockups
• El diseño de la arquitectura
• Las pruebas (Tasteware), puntos de verificación CI
• Guías de usuario
• Evaluación/revisión de código

Beneficios

• Detectar y corregir defectos de manera más eficiente
• Identificar y priorizar la ejecución de pruebas en etapas posteriores
• Prevenir defectos
o Que no son fácilmente detectables durante las pruebas dinámicas
o Durante la etapa de análisis y desarrollo
• Cubrir aspectos como:
o Inconsistencias, ambigüedades, contradicciones, definiciones inexactas, requerimientos redundantes
• Reducir el retrabajo e incrementar la productividad
• Reducir el costo y el tiempo
• Mejorando la comunicación entre todos los miembros del equipo


## Definición y diseño de pruebas ##

Esto es algo básico para cada tester. Hay varias cosas necesarias que debemos comprender y estar seguros de para qué lo hacemos.

Tu obligación y por lo que vas a brillar es porque sabes Encontrar Problemas, Documentarlos y Comunicarlos. Es crucial documentar, diseñar y nuestros casos de prueba contengan la información necesaria para que se entienda el trabajo.

¿Qué hace un tester?

Encontrar problemas
Si no encuentra problemas antes de que el producto sea entregado al cliente, entonces su testing es ineficiente.
Documentar problemas
Si cuando encuentra problemas no sabe documentar y reproducir los pasos correctos su testing genera retrabajo y sube el costo.
Comunicar problemas
Si como representante de la calidad del producto no sabe argumentar y proteger los intereses del negocio o los clientes, entonces su testing no agrega valor.

## Caja Blanca, Gris y Negra ##

Caja Blanca, Gris y Negra

Cuándo estamos refiriéndonos a “una caja” es la manera de observar el contenido del Software, ya sea que no tenemos noción más que la interfaz con la que estamos trabajando, caja negra. Cuándo podemos ver todo el contenido como una caja de cristal, caja blanca. Las integraciones, los datos cómo fluyen de un lugar a otro, dónde no conozco el código ni veo interfaz pero puedo ver cómo fluye la información a través de las redes, caja gris.

Caja Negra

• Participación de Equivalencia. Esos grupos de datos que pueden entrar para casos exitosos o para casos no exitosos.

• Valores Límite. Se puede tener usado un rango de valores.
• Tabla de Decisiones. Va enfocada si tuviéramos valores seleccionables.
• Transición de Estados. Cómo el componente se comporta.
• Casos de Uso. Realizar escenarios que pueda realizar el usuario.

Caja Blanca

• Cobertura de declaraciones. Las declaraciones son todo aquello que tienes dentro del código y estás asumiendo que es lo que se pide que haga, al decir cobertura es, dependiendo el tipo de software, los requerimientos, el objetivo, se establece un porcentaje de cobertura, esto significa que, cada línea de código debería ser ejecutada al menos una vez, cada sentencia debería de ejecutarse alguna vez.
• Cobertura de código. Que se evite tener código obsoleto.

Caja Gris

• Casos de Negocio. Es necesario conocer cómo el usuario interactúa, qué datos ingresa y qué datos van a ser retornados.
• Pruebas End to End. Cómo se están agregando datos y aún no queremos ver datos de salida.
• Pruebas de integración. Ver cómo viajan esos datos, la respuesta y la comunicación de cómo fluyen los datos entre diferentes servicios.

Cuando no estamos refiriendo a una caja es la manera de observar el contenido de software.

Negra: No podemos observar cómo fue construida, no vemos el código, no sabemos su arquitectura, no tenemos nociones más que la interfaz que estamos interactuando.

Partición de equivalencia
Valores límite
Tabla de decisiones
Transición de estados
Casos de usos
Blanca: Es como una caja de cristal, puedo ver todo lo que hay adentro e incluso puedo ser parte del equipo que desarrolla el software.

Cobertura de declaración
Cobertura de decisiones
Gris: Pueden ser la integraciones, cómo fluye el código y puedo ver como se transmiten los datos a través de las redes.

Casos de negocios
Pruebas End-to-End
Pruebas de integración


## Gestión, monitoreo y control: Monitoreo y Seguimiento ##

Aunque parezca obvio que es necesario gestionar nuestro trabajo y darle seguimiento a las pruebas y ejecución, hay estudios donde las empresas no pueden hacer esto exitosamente.

Gestión de Pruebas:

Planeación: Definir los objetivos de las pruebas es muy importante, al no tener una estrategia clara termina causando una pobre cobertura de pruebas. Los elementos a considerar para una buena planeación son la estimación, recursos, el alcance y objetivo.

Monitoreo y Control: Durante el monitoreo lo que estamos buscando son esas métricas que nos digan si estamos llevando avances o tenemos retrasos. Son nuestras alertas cuando nuestro plan no se esta ejecutando.

Análisis: Incluye decidir cuáles son esas prioridades que nos ayudará a definir qué debemos probar.

Diseño: Normalmente cuándo estas iniciando las pruebas es necesario crear un mapa de ideas. Después de esto, puedes realizar el diseño a detalle de qué va a incluir cada caso de uso. Casos de alto nivel, diseñar y priorizar pruebas, identificar el entorno de pruebas, hacer una trazabilidad entre pruebas y sus
condiciones.

Implementación: También nos aseguramos de contar con la estructura necesaria para realizar las pruebas, con un ambiente, datos y dónde documentar o realizar las pruebas.

Ejecución: En esta etapa los suites de pruebas se ejecutan de acuerdo al programa o el plan diseñado con anterioridad. Se suelen agrupar los casos de pruebas para que no estén desorganizado y podemos hacerles un buen seguimiento.

Finalización: Cuando queremos cerrar el ciclo de las pruebas, necesitamos saber qué porcentaje se cubrió, ejecutó, cuántos defectos se derivaron, aprender lecciones sobre el proceso.

Gestión, monitoreo y control: Monitoreo y Seguimiento

Gestión de Pruebas

• Planeación de pruebas. Definición de Objetivos de las pruebas, alcance de las mismas, las técnicas de pruebas que se llevarán a cabo, junto con la estimación y definición de fechas de entrega, así como los criterios de salida.
• Monitoreo y control de pruebas. Durante el monitoreo se va midiendo y comparando los resultados de las métricas, y entonces durante el control se toman acciones para alcanzar el objetivo del plan y los criterios de salida.
• Análisis de pruebas. Cuando estamos analizando las pruebas para nuestro proyecto, necesitamos determinar qué debemos probar, obviamente basados en las prioridades de cobertura.
• Diseño de pruebas. Diseñado de casos de alto nivel. Diseñar y priorizar las pruebas. Identificar los datos de pruebas. Identificar el entorno de pruebas – infraestructura y herramientas. Hacer una trazabilidad entre pruebas y sus condiciones.
• Implementación de pruebas. Para poder prepararnos para hacer las pruebas, primero tenemos que asegurarnos que tenemos todo lo necesario para ello.
• Ejecución de pruebas. Durante esta etapa, las suites de pruebas se ejecutan de acuerdo con el programa de ejecución de las pruebas.
• Finalización de las pruebas. Defectos con el estatus correcto. Reporte para comunicar los resultados de las pruebas. Finalizar y archivar ambiente de prueba y sus datos. Entregar el Testware al equipo de mantenimiento de pruebas. Analizar lecciones aprendidas para futuras versiones. Recopilar la información para ayudar a mejorar la madurez del proceso de prueba.


## Roles y Responsabilidades ##

Roles y Responsabilidades

• Especialista en pruebas manuales. Entre las habilidades que debería de tener, es el pensamiento lateral, en la parte de organización, diseño y documentación, debería de ser el especialista en entender cuáles son los casos de uso que se van a llevar para cada área, debe de poder organizarse y asignar trabajo para sí mismo dependiendo las prioridades del negocio, los riesgos o el impacto.
• Especialista en pruebas técnicas. Esta persona se tiene que encargar de estar siempre actualizada en las herramientas que le permitan acelerar el trabajo, mejorar el trabajo, búsqueda, continuo entrenamiento, ser autodidacta.
• Líder del equipo de pruebas. Gestiona el equipo y es un facilitador para las actividades a realizar, como apoyar con ambiente de pruebas, darle seguimiento a los defectos, revisar que los lineamientos se sigan.
• Ingeniero de calidad. Se dedica a la parte del proceso, es quien se encarga de establecer las políticas, mantener involucrados a los equipos, alineados a las prioridades del negocio; además que verifica que todo esto se cumpla sobre todo para la entrega del cliente.


Independientemente del rol, un tester participa de todas las etapas del proceso de desarrollo de software, colaborando para asegurar la máxima calidad del producto. Su perfil conjuga un conjunto de habilidades con el conocimiento del negocio, de la aplicación bajo prueba y de cómo planificar, diseñar, ejecutar y administrar las pruebas.

“Un tester investiga un producto de software con el objetivo de obtener información acerca de su calidad y del valor que representa para quienes lo utilizan”

Cuando el esfuerzo en la calidad se enfoca y se distribuye en roles y responsabilidades podemos encontrar que la mayoría de las empresas manejan los siguientes roles:

El tester manual, se enfoca en la estrategia, definición, ejecución y cobertura de pruebas para cumplir los requerimientos, echando mano de cualquier técnica para obtener información suficiente y así cumplir con las asignaciones correspondientes.

El tester técnico, trabaja muy de cerca con el tester manual, mientras que el tester manual define las pruebas, el tester técnico acelera la capacidad de ejecución de las pruebas. Esto lo hace implementando herramientas que permitan la automatización de pruebas, o la correcta selección de datos de pruebas, o el monitoreo de la ejecución de las pruebas.

El líder de pruebas, generalmente dentro de sus responsabilidad es volverse un facilitador de servicios, información y herramientas para el equipo de pruebas, para poder estimar presupuestos, recursos y tiempos respecto al plan de desarrollo de software.

El Ingeniero de calidad, ya no solamente está al pendiente del producto y los procesos, comienza a involucrarse más con el negocio, ayudando tanto a testers como cualquier otro miembro del equipo a llevar cabo pruebas que reduzcan, en todas las etapas del ciclo de vida del software, el error humano.


## Retrabajo ##

Es necesario identificar cada uno de los roles y responsabilidades para después evaluar si se esta haciendo o no re trabajo, es decir estamos utilizando tiempo que podría ser utilizado en otras actividades o sencillamente que no debería hacerse

También es necesario medir el rendimiento de nuestro trabajo y herramientas que nos permitan conocer paso a paso cómo vamos avanzado en el proceso de manera individual o en equipo.

Retrabajo: Es la principal causa del retraso, de que la estimación de tiempo falle, de que costos suban. Cuando estos suceden aumentamos exponencialmente el trabajo de todos

Falta o mala documentación
Falta de capacitación o dominio en las herramientas utilizadas
Falta de capacitación o dominio en el software a desarrollar
Falta de comunicación

Retrabajo

El dashboard puede ser una herramienta útil que mantiene informado a todo el equipo acerca del estatus de las pruebas.

Acciones de control

• Si identificamos un riesgo…
• Si identificamos falta de ambientes…
• Si el criterio de salida no se cumple…

Resultados de las pruebas

Hay valores como: ¿cuántas pruebas se han ejecutado? ¿cuántas de ellas no han pasado o sí han pasado? ¿cuántas derivaron defectos o no defectos pero hay un blocker que no permite continuar el trabajo?

Desempeño del equipo de testing

Muchas circunstancias alrededor de poder hacer nuestro trabajo también forman parte de estar en el proceso y administración de las tareas que le toca a cada persona.

Retrabajo: “Esfuerzo adicional necesario para la corrección de una inconformidad en algún producto. El problema que surge con el retrabajo es obvio: es un esfuerzo adicional que no puede ser cobrado al cliente, pero que es necesario para que este quede conforme con lo que hemos hecho para él.”

• Falta o mala documentación
• Falta de capacitación o dominio en las herramientas utilizadas
• Falta de capacitación o dominio en el software a desarrollar
• Falta de comunicación


## Sistema de seguimiento de bugs ##

Sistema de seguimiento de bugs

Las malas administración o prácticas, las faltas de seguimiento no sólo entorpece las tareas del equipo, sino que, además, si sumamos el retrabajo, puede que el proyecto se salga de presupuesto y de tiempo.

Razones por las que aparecen defectos

• Hay presión de tiempo en la entrega del software
• Descuidos en el diseño
• Inexperiencia o falta de conocimiento
• Falta de comunicación en los requerimientos
• Diseño complejo de código
• Desconocimiento de las tecnologías usadas

¿Cómo crear un proceso de gestión de bugs?

¿Qué debe hacer la persona que encuentre un defecto?
¿En qué herramienta se debe documentar el defecto?
¿Cómo vamos a almacenar la información?
¿Qué información requiere el equipo de desarrollo para poder resolver un defecto?
¿Cuáles son los estatus que se manejan para que fluya la resolución del defecto?
¿Cuáles son los criterios de aceptación de cierre del defecto?

Repositorio y Monitoreo de Defectos

Una vez instaurado el proceso de gestión de bugs, también se debe precisar quién tiene acceso a los bugs y cuáles son los permisos que tiene, por cuánto tiempo se almacenan, etc.

La mala administración, malas prácticas o falta de seguimiento entorpece las tareas de todo el equipo sino que además sumamos el retrabajo en la mala documentación puede que nuestro proyecto se salga de presupuesto o tiempo.

Razones por las que aparecen defectos:

Hay presión de tiempo en la entrega del software
Descuidos en el diseño
Inexperiencia o falta de conocimiento
Falta de comunicación en los requerimientos
Diseño complejo de código
Desconocimiento de las tecnologías usadas

Preguntas a realizar para construir un proceso de gestión de bugs:

¿Qué debe de hacer la persona que encuentre el defecto?
¿En qué herramienta debe documentar el defecto?
¿Cómo vamos a almacenar la información?
¿Qué información requiere el equipo de desarrollo para poder resolver un defecto?
¿Cuáles son los estatus que se manejan para que fluya la resolución del defecto?
¿Cuáles son los criterios de aceptación de cierre del defecto?


## Defectos y sugerencias ##

Dependiendo del objetivo del proyecto podemos encontrar que no todos quieren que des sugerencias, solo encuentres defectos. Cosas que pongan en riesgo por costo, prestigio o calidad del producto.

Defectos: Es aquello que no cumple los requerimientos funciones, de diseño, de arquitectura y es la consecuencia de un error humano en el código o la interpretación de la información.

Sugerencias: Es cómo la experiencia del usuario se ve afectado. La lentitud del proyecto, la legibilidad, combinación de colores, la forma de navegar no es adecuada.


Defectos y Sugerencias

Un defecto es aquello que no cumple los requerimientos ya sea funcionales, de diseño, de arquitectura, y es la consecuencia de un error humano en el código o en la interpretación de la información con la que se construyó el software.

Una sugerencia podría ser cómo la experiencia del usuario se ve afectada.

Ejemplos de sugerencias

• Ejemplo #1, el mensaje de error no comunica adecuadamente
• Ejemplo #2, el color de la pantalla, no contrasta bien con el texto
• Ejemplo #3, no recibí un correo adicional de confirmación

“Si la calidad la define el usuario final… sus sugerencias se vuelven defectos?”

Sugerencias convertidas en defectos / Actualizaciones de software

• Hace lenta la operación
• Detiene parcial o totalmente el proceso
• El contenido o el flujo confunde al usuario
• Deja cometer muchos errores al usuario
• La traducción o el lenguaje empleado no es correcto
• No funciona sin internet


## ¿Qué es la depuración? ##

Hacer testing o depuración son dos actividades diferentes. Mientras el testing sirven para encontrar defectos, la depuración nos permitirá entender por qué esta sucediendo este defecto y que actividades están implicadas en el. Ambas pueden ir de la mano y son muy importantes.

Debugger: Es una herramienta que nos ayuda a encontrar todos estos errores ya sea de sintaxis, advertencias de seguridad, etc. Nos permite ejecutar línea por línea, detener la ejecución temporalmente, visualizar el contenido de las variables, cambiar el valor del entorno de ejecución para poder ver el efecto de una corrección en el programa.

Beneficiados

Programador: Requiere cada vez que programa ir depurando lo que ejecuta y escriba para que cumpla con su objetivo
Tester: Le ayuda a reducir el tiempo de análisis que después puede ser asignado para el desarrollador
Analista: Puede ser para analisis de encontrar información de un historial sobre cómo se comporta un sistema.
Objetivo: Vamos a analizar cómo se comporta el sistema, cómo se transfieren los datos, cómo se procesa la información. Tenemos la capacidad de tener nuestro código en cualquier momento para conocer cómo funciona.

¿Qué es la Depuración?

“Uno de los principales problemas al desarrollar aplicaciones son los errores de ejecución”

Depurando (Debugging)

Actividad que sirve para encontrar, analizar y arreglar defectos.

Beneficiados

• Programador
• Tester
• Analista / Investigador

Objetivo de la depuración

Vamos a analizar lo que estamos observando de variables, cómo se comporta el sistema, cómo se transfieren los datos de un lugar a otro, cómo se procesa la información. La ventaja es que, cualquiera que usa un debugger, interno o externo, tiene la capacidad de tener en cualquier momento el código para observar cómo está pasando la información.

Errores

Oportunidades para mejorar.

Síntomas de errores

• Obtención de salida incorrecta
• Realización de operaciones fuera de lo normal
• No finalización del programa (ciclos infinitos, p. ej.)
• Caídas del programa

El depurador (debugger) permite:

• Ejecutar línea a línea
• Detener ejecución temporalmente
o En una línea de código concreta
o Bajo determinadas condiciones
• Visualizar el contenido de las variables
• Cambiar el valor del entorno de ejecución para poder ver el defecto de una corrección en el programa

Tipos de herramientas:

• Debugger
• Manual
• Local / Remota

Herramientas

• Mensaje de advertencia
• Estándares de compilación
• Verificación sintáctica y lógica


## Pruebas de Verificación ##

Las pruebas de verificación sirven para confirmar que un cambio se haya hecho o un defecto se haya corregido. Queremos verificar que lo que estamos buscando está en los requerimientos o documentación.

Pruebas de verificación

Tratan de reproducir el escenario fallido con los datos usados. Pero sería un error usar los mismo datos para después asumir que el error fue corregido.
Se buscan nuevos escenarios donde se utilicen valores relativos. Como Otras plataformas, otros sistemas operativos, otros exploradores, otros dispositivos
Pruebas de regresión

La matrices de pruebas cuando se implementan otros dispositivos u otros exploradores nos ayuda a tenerlos en cuenta nuestros puntos de verificación para que no sufran un impacto.
La matriz de prueba nos funciona para casos donde no solo vemos los defectos sino que todo lo que ya funciona siga funcionando.
Nos ayuda a tener una claridad con los casos de prueba claves que pueden ser automatizados.
Documentación

Comentarios en el código
Documentación técnica
Pruebas unitarias
Pruebas específicas
Matrices de pruebas
Plan de pruebas


Pruebas de Verificación

Sirven para confirmar que un cambio se haya hecho o un defecto se haya corregido. Queremos estar seguros, verificar, que lo que estamos buscando funcione a lo que está en los requerimientos o ya sea en lo que está documentado.

Tratan de reproducir el escenario fallido con los datos usados.

Se buscan nuevos escenarios donde se utilicen valores relativos siguiente flujos adicionales.
• Otras Plataformas
• Otros Sistemas Operativos
• Otros exploradores
• Otros dispositivos

Pruebas de regresión

• La matriz de pruebas durante el debugging nos permite identificar módulos impactados que requieren regresión
• Las pruebas de regresión ya fallaron la primera vez al no tener suficiente cobertura, debemos incorporar los nuevos datos de prueba
• Y si se puede otros más

## Técnicas de depuración ##

Las técnicas de depuración deben ir cambiando de ser reactivas a ser preventivas. Debemos recordar que parte de los principios del testing moderno es tratar de ir corrigiendo nuestras técnicas, implementar mejores prácticas y hacer uso de mejores herramientas. El debugging debería ser la última técnica que utilizas.

Técnicas de depuración:

Debugging: Observar valores de variables, detener temporalmente la aplicación.
Logs: Hacer un vaciado de cómo las variables van cambiando y es más fácil rastrear la información.
Historial: Agiliza la forma de monitorear y observar los comportamientos de nuestro software. Comparando valores, agrupando información.
Reportes: Observar anomalías, acelerar el tiempo de respuesta, prevenir ataques o fallas.
Pasos para depurar:

Ir al módulo que falla
Establecer breakpoints
Diseñar una matrix de pruebas
Establecer los datos de prueba
Comenzar a depurar


Técnicas de Depuración

Deben ir cambiando de ser reactivas a ser preventivas. Si ya podemos observar a través de estas herramientas cómo se está utilizando la información, hacia dónde viaja, quién responde, deberíamos también recordar que parte de los principios del testing moderno es tratar de ir corrigiendo nuestras técnicas, implementar mejores prácticas y hacer uso de mejores herramientas. El debugging debería de ser la última alternativa.

Debugging

• Observar valores de variables
• Detener temporalmente la aplicación

Logs

• Almacenar los valores
• Rastreo de la información

Historial

• Capacidad de análisis forense
• Comparar valores
• Agrupar información

Monitor reportes

• Prevenir ataques o fallas
• Observar anomalías
• Acelerar tiempos de respuesta

Desventajas de no usar logs

• Visibilidad nula de errores
• Metodología de trabajo no estandarizada
• Accesos e información descentralizada
• Incremento del tiempo de respuesta

Ventajas de generar un historial / reporte

• Aplicar técnicas de Machine Learning
• Mejorar la gestión y el control de la información
• Detectar amenazas de red o virus
• Prevenir fugas de información, así como comportamientos inadecuados

Fases del Debugging

Fase 1. Encontrar el Error
Fase 2. Corregir el Error

Fase 1: Pasos para Depurar

Ir al módulo que falla
Establecer breakpoints
a. En asignación de valores
b. Procesamiento de valores
c. Cambio de estados
Diseñar una matriz de pruebas
Establecer los datos de prueba
Comenzar a depurar

## Automatización de pruebas ##

En esta unidad vamos a conocer las bases para la automatización de pruebas y podemos automatizar las siguientes tipos de pruebas.

Pruebas unitarias: Tienen que ver con un pedazo de código que el desarrollador esta codificando, pero no tienen que ver con todo el flujo de negocio y proceso del software.

Pruebas de integración: Cómo hacemos que el conjunto del equipo que libera pedacitos de software funcionen juntos y no hagan defectos adicionales.

Pruebas funcionales o de aceptación: Estas pruebas no necesariamente forman parte de los requerimientos especificados por el cliente, una recomendación para automatizar estas pruebas es que deban cumplir con los requerimientos dados por el cliente.

Test Driven Development: El desarrollo va a estar enfocado haciendo primera las pruebas y después el código. Haciendo que el desarollo sea muy específico con la mayor cobertura y no pongamos líneas de código que no van a funcionar o no se usan.

Escribimos una prueba
Ejecutamos la prueba: Falla
Se escribe el código
Ejecutamos la prueba: Pasa
Behavior Driven Development: Si primeros vamos a escribir las pruebas, debemos hacerlo bien y usando un lenguaje sencillo, simple para que la sirva al equipo para entender qué es lo que queremos hacer.

## Gherkin ## 

Gherkin

Lo que quiere ayudar es a que el Tester reduzca el tiempo de convertir los casos de prueba que se hicieron de manera manual pasarlos a automatizar.

“Gherkin es un lenguaje de texto plano con estructura. Está diseñado para ser fácil de aprender y entendido por todos”

Ventajas de Gherkin

• Simple
• Palabras clave
• Estandariza los casos de uso
• Reduce el tiempo de diseño

Principales keywords usados en Gherkin

• Feature
• Scenario
• Given, When, Then, And, But (Steps)
• Background
• Scenario outline
• Examples

Gherkin es un lenguaje de texto plano con estructura, usamos palabras que no son comandos pero permiten entender en un modo de pseudocódigo qué es lo que se tiene que hacer. Esta diseñado para ser fácil de aprender y ser entendido por todos.

Ventajas

Simple
Palabras claves o keywords
Estandariza los casos de uso
Reduce el tiempo de diseño






