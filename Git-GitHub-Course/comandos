Comando para crear un repositorio localmente.
git init

Comando para agregar el usuario al repositorio.
git config ##muestra información de su funcionamiento
git config --list ##muestra la configuración por defecto de Git
git config --list --show-origin ##muestra donde están las configuraciones guardadas.
git config --global user.name 'Víctor Echeverría'
git config --global user.email 'viktoralfa19@hotmail.com'

Comandos para ver el estado del repositorio.
git status ##Muestar que archivos estan trakeados (add) o solo modificados.

Comando para ver los cambios del repositorio o de archivos especificos.
git show ## Todo el repositorio
git show [nombre_archivo]

Comando para ver los commits realizados del repositorio o de archivos especificos.
git log ## Todo el repositorio
git log [nombre_archivo]

Comando para visualizar la diferencia de las versiones de diferentes commits.
git diff uuid_commit_uno uuid_commit_dos 
## Importante el orden de los uuid, del más antiguo al más reciente y además no es necesario copiar
todo el uuid basta con los 7 primeros carácteres.

Comando para retirar del staging archivos, (stagin es el area de preparación en memoria de los archivos 
que van a ser commit(guardado en la base de datos de git))
git rm --cached nombre_archivo

Comando para agregar al staging los archivos con cambios previo al commit
git add . or [nombre_archivo]

Comando para realizar un commit de lo que esta en el staging
git commit [-m "Mensaje del commit"]

Comando para combinar dos Ramas
git merge

Muestra la historia del repositorio o de un archivo especificos
git log
git log [nombre_archivo]
git log --stat # Permite visualizar los cambios específicos en los archivos a partir del commit.


Permitir volver a una versión anterior, perdiendo todos los cambios hasta el commit al que se quiere volver,
existen dos opciones para reset, la opción --soft que no borra los archivos agregados a staging o --hard que realiza una
reversa agresiva y total borrando todo rastro de los commits realizados despues del commit al que volvimos, es decir,
no hay marcha atrás y lo que se borró se perdió para siempre.

git reset [id_commit] --soft # Mantiene las cambios agregados a staging
git reset [id_commit] --hard # Borra todos los archivos incluido staging hasta el commit al que se vuelve.
git reset HEAD # Permite borrar o vaciar todos o los archivos que se desee de staging para no ser enviados en el próximo commit.

Para volver a cargar uno, varios o todos los archivos a una versión anterior dentro del directorio principal
git checkout [id_commit] [nombre_archivo/s] # Carga fisicamente la versión del commit ingresado.
git checkout rama_local [nombre_archivo/s] #Permite volver a la versión original sin realizar afectaciones.

Si deseo reemplazar toda la versión o solo un archivo o archivos de una versión actual a una versión anterior
solamente vuelvo atrás el o los archivos que necesito y realizo un nuevo git add y commit.

git checkout [id_commit] [nombre_archivo/s] 
git add [nombre_archivo/s]
git commit -m "Comentario"

git commit -am "Comentario" #Permite realizar directamente el add sin escribirlo. Solo sirve para archivos que previamente se han realizado un add.

Se puede borrar un archivo sin necesidad de borrarlo del historial de versiones de Git.
git rm --cached [nombre_archivo_o_directorio] # Se eliminan del area de staging.
git rm --force [nombre_archivo_o_directorio] # Se eliminan del disco duro.


FLUJOS CON DIRECTORIOS REMOTOS.
Repositorio remoto se encuentra en la Nube o un servidor propio remoto.
Clonar un repositorio remoto.
git clone [url_repositorio_remoto] # Te permite tener una copia completa del repositorio remoto en local. Hace una copa del master y crea la base de datos de todos los cambios del proyecto.

Envíar los cambios al repositorio remoto.
git push origin [nombre_rama] #El head del master local lo envía al servidor remoto.

Consultar y actualizar la historia de cambios desde el repositorio remoto al local.
git fetch

Despues de realizar la consulta para copiar dentro de los archivos locales los cambios hay que fusionar los mismo.
git merge 

El merge se lo debe realizar estando en la rama que va alojar los nuevos cambios, es decir si los cambios de una rama 
deseo enviarlos a la rama Develop o la rama master, el comando merge lo debo invocar desde la rama Develop o la rama master.

Se puede realizar ambas acciones al mismo tiempo con un solo comando.
git pull origin [nombre_rama]

Crear una nueva rama desde la rama en la que te encuentras localizado.
git branch [nombre_nueva_rama]

Ver las ramas 
git branch

Con git show puedes ver que el head esta pegado a las rama principal y a sus ramas recientemente creadas

Cambiar entre ramas 
git checkout [nombre_a_cambiar]

Conflictos
Los conflictos aparecen al momento de realizar un merge o fusión. En visual studio code existe la opción de quedarse
con los cambios recientes o los cambios que deseas fusionar.
Por defecto siempre git con el tag HEAD te muestra la porción de código del repositorio en el que te encuentras ubicado 
y que entro en conflicto. Mientras que separado por dobles líneas y con el nombre de la rama origen te mestra el código 
de la rama que deseas fusionar a la rama en que te encuentras ubicado.

Agregar un repositorio remoto al proyecto actual.
Si deseas agregar la url del repositorio remoto dentro del repositorio local de Git, debes usar:

git remote add [nombre_repositorio_remoto] [url] # Por lo general el nombre del repositorio remoto siempre es "origin"
git remote add origin [url]

Para cambiar la url del repositorio remoto si existen actualizaciones o equivocaciones es:
git remote set-url origin [url]

Opción verbose

git remote -v # Nos indica las urls para realizar fetch y push

Enviar el repositorio local al repositorio remoto.
git push origin master

Al principio no te permite realizar esta opción diciendote que existen cambios no identificados en el repositorio remoto asi 
que descargue los cambios y fusione los archivos del repositorio remoto en el repositorio local.

git pull origin master # Realiza un fetch y un merge al mismo tiempo.

Puede aparecer otro error diciendo que no pued realizar la fusión ya que las historias de cambiso entre ambos repositorios no están
relacionadas, por lo que se debe forzar la fusión al menos la primera vez.

git pull origin master --allow-unrelated-histories

Despues de esto pedirá el respectivo comentario del commit de fusión y finalizará el proceso.
Tambien debe pedir las credenciales del repositorio remoto.

Finalmente se puede enviar los cambios al repositorio remoto.
git push origin master

Se puede agregar el usuario y la clave del repositorio remoto en Linux de esta manera:
git config --global credential.helper store

Esto creará un archivo denominando .git-credentials en el home del usuario. Lo malo es que las credenciales no estarán
encriptadas. Puede hacerlo también almacenandolo en cache y dandole un tiempo de vida a las credenciales.

Utilizar SSH en GitHub
Primero creamos la llave publica y privada que voy a utilizar.
ssh-geygen -t rsa -b 4096 -C "viktoralfa19@hotmail.com"

Lo dejamos en el directorio por defecto. y Le colocamos una frase de password.

Ahora debemos decirle al servicio ssh que se ha agregado una nueva llave privada para que la pueda identificar.
Confirmamos que el servicio ssh-agent esté corriendo.
eval $(ssh-agent -s)

Si esta corriendo entonces agregamos la llave privada para que lo reconozca ssh.
ssh-add ~/.ssh/id_rsa

Ahora debo borrar mi configuración credential.helper 
git config --global --unset credential.helper

Y debo borrar el archivo ~/.git-credentials

Se debe posteriormente agregar la llave publica en GitHub para tener la conección ssh completa.

Ramas importantes en Git Flow
1. Master - La rama principal, no se toca sino hasta que se coloca en producción un desarrollo.
2. Developmemt - La rama en la que se realiza el desarrollo, es donde van a parar todos los cambios que 
   multiples desarrolladores hayan realizado y es esta versión la que envíamos a pruebas al cliente o al
   equipo de QA.
3. HotFixing - Es una rama que se deriva de la rama master para realizar un cambio en caliente del código 
   en producción. Se crea cuando aparece un bug en producción que se debe mitigar lo antes posible.
4. Future - Es una rama que se puede derivar principalmente de la rama development, que por lo general las 
   creamos para asignar tareas a diversas a desarrolladores diversos y poder de esta manera pisar código 
   entre compañeros.



