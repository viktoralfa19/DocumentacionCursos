Comando para crear un repositorio localmente.
git init

Comando para agregar el usuario al repositorio.
git config ##muestra información de su funcionamiento
git config --list ##muestra la configuración por defecto de Git
git config --list --show-origin ##muestra donde están las configuraciones guardadas.
git config --global user.name 'Víctor Echeverría'
git config --global user.email 'viktoralfa19@hotmail.com'

Comandos para ver el estado del repositorio.
git status ##Muestar que archivos estan trakeados (add) o solo modificados.

Comando para ver los cambios del repositorio o de archivos especificos.
git show ## Todo el repositorio
git show [nombre_archivo]

Comando para ver los commits realizados del repositorio o de archivos especificos.
git log ## Todo el repositorio
git log [nombre_archivo]

Comando para visualizar la diferencia de las versiones de diferentes commits.
git diff uuid_commit_uno uuid_commit_dos 
## Importante el orden de los uuid, del más antiguo al más reciente y además no es necesario copiar
todo el uuid basta con los 7 primeros carácteres.

Comando para retirar del staging archivos, (stagin es el area de preparación en memoria de los archivos 
que van a ser commit(guardado en la base de datos de git))
git rm --cached nombre_archivo

Comando para agregar al staging los archivos con cambios previo al commit
git add . or [nombre_archivo]

Comando para realizar un commit de lo que esta en el staging
git commit [-m "Mensaje del commit"]

Comando para combinar dos Ramas
git merge

Muestra la historia del repositorio o de un archivo especificos
git log
git log [nombre_archivo]
git log --stat # Permite visualizar los cambios específicos en los archivos a partir del commit.


Permitir volver a una versión anterior, perdiendo todos los cambios hasta el commit al que se quiere volver,
existen dos opciones para reset, la opción --soft que no borra los archivos agregados a staging o --hard que realiza una
reversa agresiva y total borrando todo rastro de los commits realizados despues del commit al que volvimos, es decir,
no hay marcha atrás y lo que se borró se perdió para siempre.

git reset [id_commit] --soft # Mantiene las cambios agregados a staging
git reset [id_commit] --hard # Borra todos los archivos incluido staging hasta el commit al que se vuelve.
git reset HEAD # Permite borrar o vaciar todos o los archivos que se desee de staging para no ser enviados en el próximo commit.

Para volver a cargar uno, varios o todos los archivos a una versión anterior dentro del directorio principal
git checkout [id_commit] [nombre_archivo/s] # Carga fisicamente la versión del commit ingresado.
git checkout rama_local [nombre_archivo/s] #Permite volver a la versión original sin realizar afectaciones.

Si deseo reemplazar toda la versión o solo un archivo o archivos de una versión actual a una versión anterior
solamente vuelvo atrás el o los archivos que necesito y realizo un nuevo git add y commit.

git checkout [id_commit] [nombre_archivo/s] 
git add [nombre_archivo/s]
git commit -m "Comentario"

git commit -am "Comentario" #Permite realizar directamente el add sin escribirlo. Solo sirve para archivos que previamente se han realizado un add.

Se puede borrar un archivo sin necesidad de borrarlo del historial de versiones de Git.
git rm --cached [nombre_archivo_o_directorio] # Se eliminan del area de staging.
git rm --force [nombre_archivo_o_directorio] # Se eliminan del disco duro.


FLUJOS CON DIRECTORIOS REMOTOS.
Repositorio remoto se encuentra en la Nube o un servidor propio remoto.
Clonar un repositorio remoto.
git clone [url_repositorio_remoto] # Te permite tener una copia completa del repositorio remoto en local. Hace una copa del master y crea la base de datos de todos los cambios del proyecto.

Envíar los cambios al repositorio remoto.
git push origin [nombre_rama] #El head del master local lo envía al servidor remoto.

Consultar y actualizar la historia de cambios desde el repositorio remoto al local.
git fetch

Despues de realizar la consulta para copiar dentro de los archivos locales los cambios hay que fusionar los mismo.
git merge 

El merge se lo debe realizar estando en la rama que va alojar los nuevos cambios, es decir si los cambios de una rama 
deseo enviarlos a la rama Develop o la rama master, el comando merge lo debo invocar desde la rama Develop o la rama master.

Se puede realizar ambas acciones al mismo tiempo con un solo comando.
git pull origin [nombre_rama]

Crear una nueva rama desde la rama en la que te encuentras localizado.
git branch [nombre_nueva_rama]

Ver las ramas 
git branch

Con git show puedes ver que el head esta pegado a las rama principal y a sus ramas recientemente creadas

Cambiar entre ramas 
git checkout [nombre_a_cambiar]

Conflictos
Los conflictos aparecen al momento de realizar un merge o fusión. En visual studio code existe la opción de quedarse
con los cambios recientes o los cambios que deseas fusionar.
Por defecto siempre git con el tag HEAD te muestra la porción de código del repositorio en el que te encuentras ubicado 
y que entro en conflicto. Mientras que separado por dobles líneas y con el nombre de la rama origen te mestra el código 
de la rama que deseas fusionar a la rama en que te encuentras ubicado.

Agregar un repositorio remoto al proyecto actual.
Si deseas agregar la url del repositorio remoto dentro del repositorio local de Git, debes usar:

git remote add [nombre_repositorio_remoto] [url] # Por lo general el nombre del repositorio remoto siempre es "origin"
git remote add origin [url]

Para cambiar la url del repositorio remoto si existen actualizaciones o equivocaciones es:
git remote set-url origin [url]

Opción verbose

git remote -v # Nos indica las urls para realizar fetch y push

Enviar el repositorio local al repositorio remoto.
git push origin master

Al principio no te permite realizar esta opción diciendote que existen cambios no identificados en el repositorio remoto asi 
que descargue los cambios y fusione los archivos del repositorio remoto en el repositorio local.

git pull origin master # Realiza un fetch y un merge al mismo tiempo.

Puede aparecer otro error diciendo que no pued realizar la fusión ya que las historias de cambiso entre ambos repositorios no están
relacionadas, por lo que se debe forzar la fusión al menos la primera vez.

git pull origin master --allow-unrelated-histories

Despues de esto pedirá el respectivo comentario del commit de fusión y finalizará el proceso.
Tambien debe pedir las credenciales del repositorio remoto.

Finalmente se puede enviar los cambios al repositorio remoto.
git push origin master

Se puede agregar el usuario y la clave del repositorio remoto en Linux de esta manera:
git config --global credential.helper store

Esto creará un archivo denominando .git-credentials en el home del usuario. Lo malo es que las credenciales no estarán
encriptadas. Puede hacerlo también almacenandolo en cache y dandole un tiempo de vida a las credenciales.

Utilizar SSH en GitHub
Primero creamos la llave publica y privada que voy a utilizar.
ssh-keygen -t rsa -b 4096 -C "viktoralfa19@hotmail.com"

Lo dejamos en el directorio por defecto. y Le colocamos una frase de password.
La clave es: Gestion.2020

Ahora debemos decirle al servicio ssh que se ha agregado una nueva llave privada para que la pueda identificar.
Confirmamos que el servicio ssh-agent esté corriendo.
eval $(ssh-agent -s)

Si esta corriendo entonces agregamos la llave privada para que lo reconozca ssh.
ssh-add ~/.ssh/id_rsa

Ahora debo borrar mi configuración credential.helper 
git config --global --unset credential.helper

Y debo borrar el archivo ~/.git-credentials

Se debe posteriormente agregar la llave publica en GitHub para tener la conección ssh completa.

En algunas ocasiones es necesario tener configurada más de una cuenta de git en nuestro ordenador, nuestra cuenta personal y una adicional. Acá es donde surge la necesidad de tener dos o más cuentas de git en nuestro equipo.

Supongamos que ya tenemos nuestra cuenta personal configurada, vamos a configurar una cuenta laboral (porqué en ella hay repositorios privados y por ende no los podemos manejar con nuestra cuenta personal).

Para ello vamos a crear la llave publica y la llave privada SSH de la cuenta laboral (sin sustituir las que ya tenemos):

Abrimos la terminal y nos dirigimos a nuestra carpeta .ssh


Creamos la llave con el comando: ssh-keygen -t rsa -b 4096 -C "tu@correo"
ssh-keygen: Es el comando para crear la llave ssh.
-t rsa: Es el tipo de algoritmo que se va a utilizar para generar la llave.
-b 4096: Es el número de bits de la llave que se va a generar.
-C “tu@correo”: Es el email de GitHub que vamos a configurar.

A continuación nos aparecerá un mensaje el cual nos indica que se están generando las llaves pública / privada, y en este punto es importante cambiarle el nombre a la llave que vamos a generar, con el fin de evitar sustituir la que ya tenemos configurada.


Ahora nos pedirá una contraseña (la cual podemos omitir presionando Enter, al igual que su confirmación):


Luego nos va a indicar que ya se han creado las llaves, y el resultado será:


En este punto ya tenemos dos pares de llaves (la cuenta personal / la cuenta laboral).

Lo siguiente será ir a GitHub, ingresar con nuestra cuenta laboral y configurar la llave SSH que acabamos de crear en nuestro ordenador:

Setting


SSH and GPG keys


New SSH keys


Title: Será el titulo de nuestra llave, podemos colocar algo que haga referencia ejemplo: “Cuenta Laboral - Portátil”


Key: En este campo vamos a pegar nuestra llave publica: cuenta_laboral.pub). Esto lo podemos hacer desde la consola con el comando cat. En este caso copiamos: cat cuenta_laboral.pub el resultado será lo que vamos a pegar en el campo ‘key’. También podemos abrir el archivo cuenta_laboral.pub con un editor de código y copiar su contenido.


En este punto ya tenemos las dos llaves configuradas (personal / laboral).

Ahora vamos a crear un archivo llamado config el cual nos va a permitir especificarle a nuestro ordenador cuando vamos a usar la cuenta personal y cuando vamos a usar la cuenta laboral.

Desde la consola y ubicados en la carpeta .ssh copiamos: touch config (con este comando estamos creando un archivo llamado config sin extensión).


Ahora vamos a abrir ese archivo con un editor de código y vamos a colocar lo siguiente:

#CUENTA PERSONAL
Host bitbucket
Hostname bitbucket.org
User git
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa

#CUENTA LABORAL
Host github
Hostname github.com
User git
PreferredAuthentications publickey
IdentitiesOnly yes
IdentityFile ~/.ssh/cuenta_laboral

Veamos que significa cada parámetro:

#CUENTA PERSONAL / #CUENTA LABORAL: Es un comentario para hacer referencia a la cuenta
Host: Es el parámetro que hace referencia a la cuenta. En este ejemplo cuando se utilice **bitbucket **utilizará el host de bitbucket.org y hará referencia a la llave id_rsa que será la cuenta personal.
Y cuando utilice github, utilizará el host de github.com y hará referencia a la llave cuenta_laboral
Ya tenemos todos nuestros pasos de configuración listos, ahora veamos como utilizarlos:

Si trabajamos con nuestra cuenta personal sería:
git clone git@bitbucket:deveeup/repositorio.git proyecto_personal
Si trabajamos con nuestra cuenta laboral sería:
git clone git@github:deveeup/repositorio.git proyecto_empresa
El @github o @bitbucket es el mismo parámetro que colocamos en el archivo config y no necesariamente se deben llamar github o bitbucket, pueden ser @personal y @laboral y al momento de trabajar seria:
git clone git@personal:deveeup/repositorio.git proyecto_personal
git clone git@laboral:deveeup/repositorio.git proyecto_empresa

Y como último detalle podemos configurar 2 variables locales dentro de la carpeta del repositorio, con el fin de que los commits se asocie con la cuenta correcta:
git config user.name “Tu nombre"
git config user.email "tu@correo.com”

De esta forma en vez de utilizar los parámetros que se han configurado de manera global (en caso de que los tengas), pues se utilizarán los del proyecto.
Y los puedes ver con el comando: git config --list

Podrás conseguir más información de git y GitHub en el Curso profesional de Git y GitHub






Ver de una manera mucho más grafica y resumida la información del historial de un repositorio.
git log --graph --decorate --oneline

Versionamiento con TAGS

Para crar un tag lo hacemos con 
git tag -a v0.0 -m "Versión Inicial del Repositorio" [id_commit_local] # Agrega un tag al commit especificado.

para enviar los tags al repositorio remoto
git push origin --tags

para ver los tags actuales y como estan relaciondos con los commits
git tag
git show-ref --tags

para eliminar un tag que no deseo que siga registrado
git tag -d  [nombre_tag_a_borrar]

envio de nuevo los tags pero en github no se borran los tags ya que para github es el standar de como reconocer versiones de release
por ello se debe borrar de otro modo en github desde la consola.

git push origin :refs/tags/erro

De esta manera se borrará en GitHub (repositorio remoto) un tag erroneo.

Manejo de Ramas:
Presentar información de las ramas
git show-branch
git show-branch --all

Envío de ramas locales al repositorio remoto
git push origin [nombre_rama_a_enviar]

Crear ramas
git branch [nombre_nueva_rama]
git checkout -b [nombre_nueva_rama] # Crea la nueva rama y te cambias automáticamente a esa rama

Clonar un repositorio desde un repositorio remoto
git clone [url_repositorio_remoto] # Siempre y cuando el repositorio es publico no hay problemas.


Flujo de trabajo profesional con Pull requests
En un entorno profesional normalmente se bloquea la rama master, y para enviar código a dicha rama pasa por un code review
y luego de su aprobación se unen códigos con los llamados merge request.

Para realizar pruebas enviamos el código a servidores que normalmente los llamamos staging develop (servidores de pruebas)
luego de que se realizan las pruebas pertinentes tanto de código como de la aplicación estos pasan a el servidor de producción
con el ya antes mencionado merge request.

Manejo del Pull request
Por lo general la rama master no se topa ni se modifica directamente, antes se debe realizar un code review y realizar pruebas,
en un entorno parecido a producción. La rama que estará disponible para ser desplegada en el servidor de pruebas es la rama 
stagin develop.
El pull request es un estado intermedio antes de realizar el merge entre las ramas de desarrollo y la rama staging develop.
Del mismo modo para envíar los cambios a la rama master desde la rama de stagin develop se debe realizar un pull request.
Por lo general un DevOps, o administrador del entorno de desarrollo es quien se encarga del code review y de completar el merge 
a partir del Pull request o a su ves rechazarlo.

El pull request no es propio de Git, sino más bien son buenas prácticas de DevOps que han tomado los repositorios remotos como
Github, Gilab o Bitbucket para facilitar el desarrollo de código a grupos de trabajo, ya sean estos grupos de trabajo empresariales,
o solo aportes personales a Codigo Open Source.

Cuando se manejan grupos de colaboradores de codigo Open Source la manera de manejar estos pull request se lo realiza de una 
manera ligeramente diferente.

Primero el proyecto debe ser público y las personas que van a colaborar en realidad no estan presentes en la configuración del
repositorio como colaboradores.

Para poder colaborar con proyectos open source, se debe realizar un Fork del proyecto.
Un Fork es básicamente realizar una copia del estado actual del proyecto y clonarlo. Y se clona como un proyecto propio.
Es una bifurcación, o sepración del proyecto original clonando el estado actual. 
Del mismo modo Fork es una característica propia de Github.

Una vez que se hayan hecho las contribuciones necesarias al proyecto open source, entonces podemos realizar un pull request 
a la rama que originó el fork.

La situación se vuelve interesante cuando el repositorio de codigo abierto al que realizas aportaciones tiene más cambios que el
tuyo. Es decir esta más adelante en commits. Entonces lo que se debe hacer es:
1.- Primero debemos crearnos otra variable en la configuración actual del repositorio local, que haga referencia al repositorio
publico de codigo abierto al que se esta contribuyendo.

Ejemplo:
git remote add upstream https://github.com/viktoralfa19/DocumentacionCursos.git 

# Pero lo debemos hacer con https y con ssh ya 
que no tenemos configurada un llave pública en ese respositorio.

Verificamos que tenemos un nuevo origen de información.
git remote -v

Ahora si podemos realizar un pull desde nuesto nuevo origen de datos de codigo.

Ejemplo:
git pull upstream master
#Lo que se esta realizando aqui es que actaulizamos nuestros archivos y la base de datos de cambios, desde upstream hasta 
nuestra rama master local.

Ignorar archivos en el repositorio con .gitignore
No todos los archivos que agregas a un proyecto deberían ir a un repositorio, por ejemplo cuando tienes un archivo donde
están tus contraseñas que comúnmente tienen la extensión .env o cuando te estás conectando a una base de datos; son archivos
que nadie debe ver.

Se debe crear un archivo denominado .gitignore en la raíz del repositorio,
para que mediante la configuración que se realice en este archivo, se pueda descartar archivos y directorios que no se deseen 
trakear y subirlos al repositorio remoto.


Readme.md es una excelente práctica
README.md es una excelente práctica en tus proyectos, md significa Markdown es un especie de código que te permite cambiar
la manera en que se ve un archivo de texto.

Lo interesante de Markdown es que funciona en muchas páginas, por ejemplo la edición en Wikipedia; es un lenguaje intermedio
que no es HTML, no es texto plano, es una manera de crear excelentes texto formateados.

Tu sitio web público con GitHub Pages
GitHub tiene un servicio de hosting gratis llamado GitHub Pages, tu puedes tener un repositorio donde el contenido del
repositorio se vaya a GitHub y se vea online.

Git Rebase: Reorganizando el trabajo realizado

El comando rebase es una muy mala práctica cuando se envía a repositorios remotos, ya que reescribe la historia del repositorio.
La historia de los repositorios remotos debe permanecer intacta.
Esta práctica solo se la debería realizar en local, es decir en repositorios locales.

En este momento se está realizando un rebase desde la rama experimentos a la rama master.
Siempre que se quiere realizar un rebase se debe hacer primero rebase de la rama que se utiliza para arreglar errores ya
posteriormente se realiza el rebase desde la rama que quedará finalmente con las correciones realizadas.
La diferencia con merge será que la rama experimentos nunca quedará registrada dentro del historial de master.

Primero: Estado en la rama experimentos, con los arreglos silenciosos.
git rebase master

Posteriomente para ver los resultados hacemos cambios en master y los commiteamos. Regresamos a experimentos.
y luego ejecutamos 

git rebase master

Lo que se hizo fue volver la rama master atras de la rama experimentos para hacer parecer que los cambios recientes en master
si hicieron antes de los cambios en la rama experimentos, lo que no fue así ya que se hicieron primero los cambios en 
experimentos y posteriormente en master.

Ahora volvemos a master y ejecutamos
git rebase experimentos

Lo que sucedio es que se igualan la rama master y la rama experimentos en el último commit de master, y si borramos 
la rama experimentos no pasará nada, y esta nunca registra cambios en la rama en el historial.

Posteriormente borramos la rama experimento y no ha pasado nada.
Incluso antes de borrar hacemos un cambio en master y luego borramos experimento y es como que experimento nunca existió,
No se sabe quien la creo, quien hizo cambio etc.

Ramas importantes en Git Flow
1. Master - La rama principal, no se toca sino hasta que se coloca en producción un desarrollo.
2. Developmemt - La rama en la que se realiza el desarrollo, es donde van a parar todos los cambios que 
   multiples desarrolladores hayan realizado y es esta versión la que envíamos a pruebas al cliente o al
   equipo de QA.
3. HotFixing - Es una rama que se deriva de la rama master para realizar un cambio en caliente del código 
   en producción. Se crea cuando aparece un bug en producción que se debe mitigar lo antes posible.
4. Future - Es una rama que se puede derivar principalmente de la rama development, que por lo general las 
   creamos para asignar tareas a diversas a desarrolladores diversos y poder de esta manera pisar código 
   entre compañeros.



